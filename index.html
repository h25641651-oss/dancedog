<!doctype html>
<html lang="en">
<head>
 <link rel="manifest" href="manifest.json">
 <meta name="theme-color" content="#000000">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-        scalable=no">

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Dancedog</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>

    html, body { touch-action: none; overscroll-behavior: none; }
    :root { --beige:#f5f5dc; --black:#000; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: #000; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
      user-select: none;
    }
    #game-wrapper {
      position: relative; width: 100vw; height: 100vh;
      display: flex; align-items: center; justify-content: center;
    }
    canvas{
      width: 100vw; height: 100vh; display:block;
      object-fit: contain;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:#000;
      z-index: 1;
    }

    /* High-res UI plane (text/buttons) aligned to canvas' actual displayed rect */
    #ui-plane{
      position:absolute; z-index: 10;
      pointer-events:none;
      overflow:hidden;
      box-sizing:border-box;
      display:flex; flex-direction:column;
      padding: 12px;
      gap: 10px;
    }

    #title-text{
      color:#fff;
      font-family:'Press Start 2P', monospace;
      font-size: 24px;
      margin:0;
      line-height:1;
      text-align:left;
      text-shadow: 2px 2px 0 #000;
    }

    #top-instructions{
      color:#fff;
      font-family:'Press Start 2P', monospace;
      font-size: 12px;
      line-height: 1.35;
      text-shadow: 2px 2px 0 #000;
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      align-items:center;
      pointer-events:none;
      min-height: 34px;
    }
    #top-instructions img{
      width: 18px; height: 18px;
      image-rendering: pixelated;
      vertical-align: middle;
    }

    .menu-row{
      display:flex; gap: 10px;
      pointer-events:auto;
      margin-left: -4px;
    }
    .btn{
      color:#000;
      font-family:'Press Start 2P', monospace;
      font-size: 18px;
      cursor:pointer;
      padding: 6px 10px;
      border:none;
      background: var(--beige);
      transition: transform .08s, background .08s;
      line-height:1;
      pointer-events:auto;
    }
    .btn:hover{ background:#e1e1b5; }
    .btn:active{ transform: scale(.96); }

    /* Overlay panels */
    .panel {
      position:absolute;
      background: var(--beige);
      color:#000;
      z-index: 30;
      outline: 6px solid #000;
      box-sizing:border-box;
      display:none;
      flex-direction:column;
      padding: 10px;
      pointer-events:auto;
      font-family:'Press Start 2P', monospace;
    }
    .panel h2{
      margin: 0 0 10px 0;
      font-size: 22px;
      text-align:center;
      text-decoration: underline;
    }
    .panel p{
      margin: 6px 0;
      font-size: 12px;
      line-height: 1.55;
    }
    .panel .row{
      display:flex; gap: 10px; justify-content:center; flex-wrap:wrap;
      margin-top: 10px;
    }
    .mini-icon{
      width: 18px; height: 18px;
      image-rendering: pixelated;
      vertical-align: middle;
    }

    #copy-btn{
      position:absolute;
      top:10px; right:10px;
      z-index: 100;
      padding: 8px 12px;
      background:#333;
      color:#fff;
      border: 1px solid #555;
      font-family: sans-serif;
      font-size: 12px;
      cursor:pointer;
      border-radius: 4px;
      pointer-events:auto;
    }

    #status{
      position:absolute;
      bottom:10px; left:10px;
      z-index: 100;
      color: rgba(255,255,255,.55);
      font-family: monospace;
      font-size: 10px;
      pointer-events:none;
    }

    /* Play-mode timer + chest */
    #hud-right{
      position:absolute;
      bottom: 10px;
      right: 10px;
      z-index: 50;
      pointer-events:none;
      display:none;
      gap: 10px;
      align-items:flex-end;
    }
    .hud-box{
      background: rgba(0,0,0,.6);
      border: 2px solid rgba(255,255,255,.25);
      padding: 8px 10px;
      border-radius: 6px;
    }
    #hourglass{
      font-family:'Press Start 2P', monospace;
      color:#fff;
      font-size: 16px;
      line-height: 1.0;
      text-align:center;
      text-shadow: 2px 2px 0 #000;
      width: 46px;
    }
    #hourglass .top{ display:block; }
    #hourglass .bottom{ display:block; margin-top: 6px; }
    #chest{
      font-family:'Press Start 2P', monospace;
      color: #ffd46a;
      font-size: 12px;
      text-shadow: 2px 2px 0 #000;
      white-space:nowrap;
    }

  </style>
</head>

<body>
  <div id="game-wrapper">
    <button id="copy-btn">Copy Code</button>

    <!-- NOTE: keep a small internal resolution for pixel art; we set canvas.width/height after loading. -->
    <canvas id="gameCanvas" width="65" height="142"></canvas>

    <!-- UI plane follows canvas' actual displayed rect -->
    <div id="ui-plane">
      <h1 id="title-text">Dancedog</h1>

      <div id="top-instructions"></div>

      <div class="menu-row" id="menu-row">
        <div class="btn" id="btn-practice">Practice</div>
        <div class="btn" id="btn-play">Play</div>
      </div>
    </div>

    <!-- PRACTICE / PLAY setup + rules -->
    <div class="panel" id="rules-panel">
      <h2>Rules</h2>
      <p>1. Move a hand <img class="mini-icon" id="icon-hand" alt="hand"></p>
      <p>(Hands set the directions for feet.)</p>
      <p>2. Move both feet <img class="mini-icon" id="icon-hoof" alt="hoof"> / <img class="mini-icon" id="icon-paw" alt="paw"> onto vacant squares.</p>
      <p>If you cannot move a foot, you trip and lose.</p>

      <p style="margin-top:10px; text-align:center;">Choose your side:</p>
      <div class="row">
        <button class="btn" id="choose-hoof">Hoof</button>
        <button class="btn" id="choose-paw">Paw</button>
      </div>

      <div class="row" style="margin-top:12px;">
        <button class="btn" id="start-mode">Start</button>
        <button class="btn" id="cancel-mode">Cancel</button>
      </div>
    </div>

    <!-- END / REMATCH -->
    <div class="panel" id="end-panel">
      <h2 id="end-title">Paw wins!</h2>
      <p id="end-sub" style="text-align:center;">Rematch or abandon?</p>
      <div class="row">
        <button class="btn" id="btn-rematch">Rematch</button>
        <button class="btn" id="btn-abandon">Abandon</button>
      </div>
    </div>

    <!-- "Skint" panel for Play mode -->
    <div class="panel" id="skint-panel">
      <h2>You're skint!</h2>
      <p style="text-align:center;">Recharge</p>
      <div class="row">
        <button class="btn" id="btn-skint-ok">OK</button>
      </div>
    </div>

    <div id="hud-right">
      <div class="hud-box" id="hourglass">
        <span class="top" id="hg-top">3</span>
        <span class="bottom" id="hg-bottom">0</span>
      </div>
      <div class="hud-box" id="chest">CHEST: <span id="chest-num">12</span></div>
    </div>

    <div id="status">Ready</div>
  </div>

<script>
(() => {
  // =========================
  // Assets
  // =========================
  const baseUrl = "https://raw.githubusercontent.com/thegoldenfloret/Dancedog/main/";
  const assets = {
    dog:     { url: baseUrl + "Example.png", img: new Image() },
    tablet:  { url: baseUrl + "Tablet.png", img: new Image() },

    paw:     { url: baseUrl + "Paw.png", img: new Image() },
    hoof:    { url: baseUrl + "Hoof.png", img: new Image() },
    hand:    { url: baseUrl + "Hand.png", img: new Image() },
    spot:    { url: baseUrl + "Spot.png", img: new Image() }, // if missing, we fallback-draw

    mice1:   { url: baseUrl + "Mice1.png", img: new Image() },
    mice2:   { url: baseUrl + "Mice2.png", img: new Image() },

    dogwin:  { url: baseUrl + "Dogwin.png", img: new Image() }, // Paw wins
    goatwin: { url: baseUrl + "Goatwin.png", img: new Image() }, // Hoof wins

    dogstep: { url: baseUrl + "Dogstep.png", img: new Image() }, // Paw first-step indicator (as you described)
    goatstep:{ url: baseUrl + "Goatstep.png", img: new Image() }, // Hoof first-step indicator

    dance1:  { url: baseUrl + "Dance1.png", img: new Image() },
    dance2:  { url: baseUrl + "Dance2.png", img: new Image() },

    // Optional play-mode assets (if you add these files to your repo later, they'll just start working):
    coin:    { url: baseUrl + "Coin.png", img: new Image(), optional:true },
    open:    { url: baseUrl + "Open.png", img: new Image(), optional:true },
    close:   { url: baseUrl + "Close.png", img: new Image(), optional:true },
  };

  // =========================
  // DOM
  // =========================
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const uiPlane = document.getElementById("ui-plane");
  const menuRow = document.getElementById("menu-row");
  const topInstructions = document.getElementById("top-instructions");

  const status = document.getElementById("status");
  const copyBtn = document.getElementById("copy-btn");

  const rulesPanel = document.getElementById("rules-panel");
  const chooseHoofBtn = document.getElementById("choose-hoof");
  const choosePawBtn = document.getElementById("choose-paw");
  const startModeBtn = document.getElementById("start-mode");
  const cancelModeBtn = document.getElementById("cancel-mode");

  const endPanel = document.getElementById("end-panel");
  const endTitle = document.getElementById("end-title");
  const btnRematch = document.getElementById("btn-rematch");
  const btnAbandon = document.getElementById("btn-abandon");

  const skintPanel = document.getElementById("skint-panel");
  const btnSkintOk = document.getElementById("btn-skint-ok");

  const hudRight = document.getElementById("hud-right");
  const hgTop = document.getElementById("hg-top");
  const hgBottom = document.getElementById("hg-bottom");
  const chestNum = document.getElementById("chest-num");

  // menu buttons
  const btnPractice = document.getElementById("btn-practice");
  const btnPlay = document.getElementById("btn-play");

  // icons in rules panel
  const iconHand = document.getElementById("icon-hand");
  const iconHoof = document.getElementById("icon-hoof");
  const iconPaw  = document.getElementById("icon-paw");

  // =========================
  // Load assets
  // =========================
  let loadedCount = 0;
  const totalAssets = Object.keys(assets).length;

  function onAssetLoaded() {
    loadedCount++;
    status.textContent = `Loading: ${loadedCount}/${totalAssets}`;
    if (loadedCount === totalAssets) {
      // attach icons
      iconHand.src = assets.hand.url;
      iconHoof.src = assets.hoof.url;
      iconPaw.src  = assets.paw.url;
      initCanvasSize();
      syncUIRects();
      startIdleAnimations();
      render();
      status.textContent = "Ready";
    }
  }

  Object.keys(assets).forEach(k => {
    const a = assets[k];
    a.img.crossOrigin = "anonymous";
    a.img.onload = onAssetLoaded;
    a.img.onerror = () => {
      // Optional assets shouldn't block gameplay.
      if (a.optional) {
        console.warn("Optional asset missing:", a.url);
      } else {
        console.error("Failed to load:", a.url);
      }
      onAssetLoaded();
    };
    a.img.src = a.url;
  });

  // =========================
  // Coordinate maps (from your working placement)
  // =========================
  const handPositions = {
    a: { x: 0,  y: 58 },
    b: { x: 28, y: 58 },
    c: { x: 55, y: 58 },
    d: { x: 55, y: 85 },
    e: { x: 55, y: 113 },
    f: { x: 27, y: 113 },
    g: { x: 0,  y: 113 },
    h: { x: 0,  y: 85 }
  };
  const handOrder = ["a","b","c","d","e","f","g","h"];

  // 4x4 grid mapping (1..16)
  const gridX = [11, 22, 33, 44];
  const gridY = [69, 80, 91, 102];
  const gridPos = {}; // {1:{x,y}, ... 16:{x,y}}
  let idx = 1;
  for (const y of gridY) for (const x of gridX) gridPos[idx++] = {x,y};

  // =========================
  // Game state
  // =========================
  const Mode = { NONE:"none", PRACTICE:"practice", PLAY:"play" };
  let currentMode = Mode.NONE;

  // Selection + starters
  let playerSide = "hoof"; // "hoof" | "paw"
  let botSide = "paw";
  let startingSide = "hoof"; // alternates with rematch

  // Turn machine
  const Phase = { HAND:"hand", FEET:"feet", END:"end" };
  let turnSide = "hoof";         // whose turn right now
  let phase = Phase.HAND;
  let feetToMove = 2;            // during FEET phase
  let moveLock = false;          // prevents input during bot actions / animations
  let lastStepSide = null;       // for showing step overlay (hoof/paw)
  let stepOverlayVisible = false;

  // Dance & mice animation toggles
  let danceToggle = 0;           // 0 -> dance1, 1 -> dance2
  let miceFrame = 0;             // 0 -> mice1, 1 -> mice2
  let miceTimer = null;

  // Win overlays
  let winOverlay = null;         // "dogwin" | "goatwin" | null

  // Hands: two tokens
  let hands = [
    { id:"H1", pos:"h" },
    { id:"H2", pos:"d" },
  ];

  // Feet: each side has 2 feet. We store square index 1..16
  let feet = {
    hoof: [14, 15],
    paw:  [2, 3],
  };

  // "Invert" drawing when player chooses Paw (vertical flip of sprites so they appear correct)
  let invertPlayerSprites = false; // you asked: if paw chosen, hoof/paw flipped vertically

  // Dragging
  let drag = {
    active:false,
    type:null,        // "hand" | "foot"
    which:null,       // hand index 0/1, or foot index 0/1
    side:null,        // "hoof"|"paw" for foot
    startPointer:null,
    legalTargets:[],  // for foot drags (list of square indices)
  };

  // End screen / rematch
  let gameOver = false;

  // PLAY mode: timer + coins + chest
  let turnSecondsLeft = 30;
  let turnTimerId = null;
  let botActionTimeouts = []; // to clear on abandon
  let coins = new Set(); // squares with coins
  let chest = 12;        // starts at 12; in Play: each turn costs 1 "energy"; coins add +1 (recharge)
  let chestOpenFlash = 0; // 0 none, >0 remaining ms of open/close sequence

  // =========================
  // Helpers
  // =========================
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function opposite(side){ return side === "hoof" ? "paw" : "hoof"; }

  function inBoundsSquare(sq){ return sq >= 1 && sq <= 16; }

  function rcFromSq(sq){
    const r = Math.floor((sq-1)/4);
    const c = (sq-1)%4;
    return {r,c};
  }
  function sqFromRC(r,c){ return r*4 + c + 1; }

  function isVacantSquare(sq){
    return !feet.hoof.includes(sq) && !feet.paw.includes(sq);
  }

  function getHandDirVectors() {
    // directions in row/col (r down positive)
    return {
      a: {dr:-1, dc:-1},
      b: {dr:-1, dc: 0},
      c: {dr:-1, dc: 1},
      d: {dr: 0, dc: 1},
      e: {dr: 1, dc: 1},
      f: {dr: 1, dc: 0},
      g: {dr: 1, dc:-1},
      h: {dr: 0, dc:-1},
    };
  }

  function handNeighbors(pos){
    const i = handOrder.indexOf(pos);
    const cw  = handOrder[(i+1) % handOrder.length];
    const ccw = handOrder[(i-1+handOrder.length) % handOrder.length];
    return {cw, ccw};
  }

  function legalMovesForFoot(side, footIndex){
    const dirs = getHandDirVectors();
    // A foot can move if any hand occupies a position;
    // multiple hands at same letter just means same direction exists (still one direction).
    const occupiedHandLetters = new Set(hands.map(h => h.pos));
    const fromSq = feet[side][footIndex];
    const {r,c} = rcFromSq(fromSq);

    const targets = [];
    for (const letter of occupiedHandLetters) {
      const v = dirs[letter];
      const nr = r + v.dr;
      const nc = c + v.dc;
      if (nr < 0 || nr > 3 || nc < 0 || nc > 3) continue;
      const nsq = sqFromRC(nr, nc);
      if (isVacantSquare(nsq)) targets.push(nsq);
    }
    // unique
    return Array.from(new Set(targets));
  }

  function sideHasAnyFootMove(side){
    const m0 = legalMovesForFoot(side, 0);
    const m1 = legalMovesForFoot(side, 1);
    return m0.length > 0 || m1.length > 0;
  }

  function updateTopText(){
    // Practice/Play: show whose turn it is + what to do
    if (currentMode === Mode.NONE) {
      topInstructions.innerHTML = "";
      return;
    }
    if (gameOver) {
      topInstructions.innerHTML = "";
      return;
    }

    const isPlayerTurn = (turnSide === playerSide);
    const who = (turnSide === "hoof") ? "Hoof" : "Paw";

    if (!isPlayerTurn) {
      topInstructions.innerHTML = `${who.toLowerCase()} is thinking...`;
      return;
    }

    if (phase === Phase.HAND) {
      topInstructions.innerHTML = `Your turn (${who}). Move a hand <img src="${assets.hand.url}" alt="hand">`;
    } else if (phase === Phase.FEET) {
      const footIcon = (playerSide === "hoof") ? assets.hoof.url : assets.paw.url;
      topInstructions.innerHTML = `Your turn (${who}). Move your feet <img src="${footIcon}" alt="foot">`;
    } else {
      topInstructions.innerHTML = "";
    }
  }

  // =========================
  // UI panel positioning
  // =========================
  function initCanvasSize(){
    // Use the background "Example.png" natural size as the internal pixel grid.
    canvas.width  = assets.dog.img.naturalWidth  || 128;
    canvas.height = assets.dog.img.naturalHeight || 128;
  }

  function getCanvasActualRect(){
    // compute actual displayed rect of the canvas content (object-fit: contain)
    const rect = canvas.getBoundingClientRect();
    const canvasAspect = canvas.width / canvas.height;
    const screenAspect = rect.width / rect.height;

    let actualW, actualH, actualLeft, actualTop;

    if (screenAspect > canvasAspect) {
      actualH = rect.height;
      actualW = actualH * canvasAspect;
      actualTop = rect.top;
      actualLeft = rect.left + (rect.width - actualW) / 2;
    } else {
      actualW = rect.width;
      actualH = actualW / canvasAspect;
      actualLeft = rect.left;
      actualTop = rect.top + (rect.height - actualH) / 2;
    }
    return {actualW, actualH, actualLeft, actualTop};
  }

  function syncUIRects(){
    const {actualW, actualH, actualLeft, actualTop} = getCanvasActualRect();
    uiPlane.style.width  = Math.floor(actualW) + "px";
    uiPlane.style.height = Math.floor(actualH) + "px";
    uiPlane.style.left   = Math.floor(actualLeft) + "px";
    uiPlane.style.top    = Math.floor(actualTop) + "px";

    // rules panel sits on tablet area proportionally
    const tabletNaturalH = assets.tablet.img.naturalHeight || 0;
    const tabletRatio = tabletNaturalH / (assets.dog.img.naturalHeight || 128);
    const overlayH = actualH * tabletRatio;

    // position rules panel / end panel / skint panel over tablet
    [rulesPanel, endPanel, skintPanel].forEach(panel => {
      panel.style.width  = Math.floor(actualW) + "px";
      panel.style.height = Math.floor(overlayH) + "px";
      panel.style.left   = Math.floor(actualLeft) + "px";
      panel.style.top    = Math.floor(actualTop + (actualH - overlayH)) + "px";
    });

    // HUD right is outside uiPlane alignment, but we can show it; leave absolute in wrapper.
  }

  window.addEventListener("resize", () => {
    syncUIRects();
    render();
  });

  // =========================
  // Idle animations (mice clap)
  // =========================
  function startIdleAnimations(){
    if (miceTimer) clearInterval(miceTimer);
    miceTimer = setInterval(() => {
      miceFrame = (miceFrame + 1) % 2;
      render();
    }, 500);
  }

  // =========================
  // Menu / mode selection
  // =========================
  let pendingMode = Mode.PRACTICE;

  btnPractice.addEventListener("click", () => {
    pendingMode = Mode.PRACTICE;
    openRulesPanel();
  });

  btnPlay.addEventListener("click", () => {
    pendingMode = Mode.PLAY;
    openRulesPanel();
  });

  function openRulesPanel(){
    // show rules + choose side + start
    rulesPanel.style.display = "flex";
    // default choose hoof for a new session
    selectSide("hoof");
  }

  cancelModeBtn.addEventListener("click", () => {
    rulesPanel.style.display = "none";
  });

  chooseHoofBtn.addEventListener("click", () => selectSide("hoof"));
  choosePawBtn.addEventListener("click", () => selectSide("paw"));

  function selectSide(side){
    playerSide = side;
    botSide = opposite(side);
    // If paw chosen: invert hoof & paw sprites vertically (as requested)
    invertPlayerSprites = (playerSide === "paw");

    chooseHoofBtn.style.outline = (side === "hoof") ? "4px solid #000" : "none";
    choosePawBtn.style.outline  = (side === "paw")  ? "4px solid #000" : "none";
  }

  startModeBtn.addEventListener("click", () => {
    rulesPanel.style.display = "none";
    startGame(pendingMode);
  });

  // =========================
  // Start/reset game
  // =========================
  function resetBoard({keepCoins=false} = {}){
    hands = [{id:"H1", pos:"h"}, {id:"H2", pos:"d"}];

    // Starting positions depend on player choice:
    // If player is hoof: hoof 14/15 paw 2/3
    // If player is paw: paw at 14/15 and hoof at 2/3 (sprites inverted for correct look)
    if (playerSide === "hoof") {
      feet.hoof = [14, 15];
      feet.paw  = [2, 3];
    } else {
      feet.paw  = [14, 15];
      feet.hoof = [2, 3];
    }

    phase = Phase.HAND;
    feetToMove = 2;
    turnSide = startingSide;
    moveLock = false;
    lastStepSide = null;
    stepOverlayVisible = false;
    winOverlay = null;
    gameOver = false;

    if (!keepCoins) coins = new Set();

    // play-mode per turn
    stopTurnTimer();
    turnSecondsLeft = 30;
    updateHourglass(turnSecondsLeft);
    updateTopText();
    render();

    // if bot starts, kick it off
    if (turnSide === botSide) runBotTurn().catch(console.error);
  }

  function startGame(mode){
    currentMode = mode;
    menuRow.style.display = "none"; // hide menu
    endPanel.style.display = "none";
    skintPanel.style.display = "none";

    // Practice always begins a new game with Hoof first (as you said Hoof always begins).
    // But you also said rematch alternates starter.
    // So on first start: hoof begins; rematches toggle.
    startingSide = "hoof";

    // Play HUD
    if (currentMode === Mode.PLAY) {
      hudRight.style.display = "flex";
      chest = 12; // starts at 12
      chestNum.textContent = String(chest);
      coins = new Set();
    } else {
      hudRight.style.display = "none";
    }

    resetBoard({keepCoins:false});
  }

  // =========================
  // Endgame + rematch/abandon
  // =========================
  function showEnd(winnerSide){
    gameOver = true;
    phase = Phase.END;
    stopTurnTimer();
    moveLock = true;

    // Overlays:
    // "Paw wins!" => Dogwin.png
    // "Hoof wins!" => Goatwin.png
    if (winnerSide === "paw") {
      endTitle.textContent = "Paw wins!";
      winOverlay = "dogwin";
    } else {
      endTitle.textContent = "Hoof wins!";
      winOverlay = "goatwin";
    }

    endPanel.style.display = "flex";
    updateTopText();
    render();
  }

  btnAbandon.addEventListener("click", () => {
    abandonToMenu();
  });

  function abandonToMenu(){
    stopTurnTimer();
    botActionTimeouts.forEach(id => clearTimeout(id));
    botActionTimeouts = [];

    currentMode = Mode.NONE;
    menuRow.style.display = "flex";
    rulesPanel.style.display = "none";
    endPanel.style.display = "none";
    skintPanel.style.display = "none";
    hudRight.style.display = "none";

    // Reset to idle view
    gameOver = false;
    startingSide = "hoof";
    winOverlay = null;
    phase = Phase.HAND;
    turnSide = "hoof";
    feetToMove = 2;
    moveLock = false;
    coins = new Set();
    chest = 12;
    chestNum.textContent = "12";
    updateTopText();
    render();
  }

  btnRematch.addEventListener("click", () => {
    endPanel.style.display = "none";

    // Alternate who starts next
    startingSide = opposite(startingSide);

    const keepCoins = (currentMode === Mode.PLAY); // play keeps coins between rematches
    resetBoard({keepCoins});

    // In Play mode: you said coins stay on rematch; and starter alternates based on previous game.
    // That's what we do: startingSide toggled above.
  });

  btnSkintOk.addEventListener("click", () => {
    skintPanel.style.display = "none";
    // you can still play practice; leaving play running would be weird
    abandonToMenu();
  });

  // =========================
  // Turn timer (Play mode)
  // =========================
  function updateHourglass(seconds){
    // Display like: top digit and bottom digit for "30" -> top 3 bottom 0
    const s = clamp(seconds, 0, 99);
    const tens = Math.floor(s / 10);
    const ones = s % 10;
    hgTop.textContent = String(tens);
    hgBottom.textContent = String(ones);
  }

  function stopTurnTimer(){
    if (turnTimerId) clearInterval(turnTimerId);
    turnTimerId = null;
  }

  function startTurnTimer(){
    if (currentMode !== Mode.PLAY) return;
    stopTurnTimer();
    updateHourglass(turnSecondsLeft);

    turnTimerId = setInterval(() => {
      if (gameOver) { stopTurnTimer(); return; }
      // Only tick on player turns (your spec: player & bot timed; but bot takes random time <=20s;
      // we'll still tick overall for simplicity)
      turnSecondsLeft--;
      updateHourglass(turnSecondsLeft);
      render();

      if (turnSecondsLeft <= 0) {
        // Time out: any foot not moved becomes coin; show winner based on who timed out
        stopTurnTimer();
        handleTimeoutLoss();
      }
    }, 1000);
  }

  function handleTimeoutLoss(){
    // If player timed out: winner is opponent.
    // Replace any foot that hasn't been moved THIS TURN with a coin.
    // We track "feetToMove" and assume 2 feet need movement during the FEET phase.
    // If timeout occurs during HAND phase, both feet are "not moved".
    // If timeout occurs during FEET phase and feetToMove==1, one remaining.
    const loser = turnSide;
    const winner = opposite(loser);

    // Which squares become coins? The squares occupied by any feet that were supposed to move but didn't.
    // In practice you'd want per-foot moved tracking; we approximate with "remaining feet count".
    // We'll coin up to `feetToMove` feet from that side (starting from foot 0).
    const sideFeet = feet[loser].slice();
    const count = (phase === Phase.HAND) ? 2 : feetToMove;
    for (let i=0; i<count; i++){
      const sq = sideFeet[i];
      if (sq != null) coins.add(sq);
    }

    showEnd(winner);
  }

  // =========================
  // Input mapping: pointer to canvas coords
  // =========================
  function pointerToCanvasXY(clientX, clientY){
    const {actualW, actualH, actualLeft, actualTop} = getCanvasActualRect();
    const nx = (clientX - actualLeft) / actualW;
    const ny = (clientY - actualTop) / actualH;
    return {
      x: nx * canvas.width,
      y: ny * canvas.height
    };
  }

  function hitTestHand(x,y){
    // return {handIndex} if near a hand sprite
    // the hand sprite is drawn at handPositions letter coords.
    // We'll use a simple box around that coordinate.
    for (let i=0;i<hands.length;i++){
      const p = handPositions[hands[i].pos];
      const w = assets.hand.img.naturalWidth || 10;
      const h = assets.hand.img.naturalHeight || 10;
      if (x >= p.x && x <= p.x + w && y >= p.y && y <= p.y + h) return {handIndex:i};
    }
    return null;
  }

  function hitTestFoot(x,y){
    // return {side, footIndex} if hit a foot sprite
    for (const side of ["hoof","paw"]){
      for (let i=0;i<2;i++){
        const sq = feet[side][i];
        const p = gridPos[sq];
        const img = (side === "hoof") ? assets.hoof.img : assets.paw.img;
        const w = img.naturalWidth || 10;
        const h = img.naturalHeight || 10;
        if (x >= p.x && x <= p.x + w && y >= p.y && y <= p.y + h) return {side, footIndex:i};
      }
    }
    return null;
  }

  // =========================
  // Player input (mouse/touch)
  // =========================
  function canPlayerAct(){
    if (gameOver) return false;
    if (moveLock) return false;
    if (turnSide !== playerSide) return false;
    return true;
  }

  function onPointerDown(ev){
    if (!canPlayerAct()) return;
    const pt = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
    const {x,y} = pointerToCanvasXY(pt.clientX, pt.clientY);

    if (phase === Phase.HAND){
      const hh = hitTestHand(x,y);
      if (!hh) return;
      drag.active = true;
      drag.type = "hand";
      drag.which = hh.handIndex;
      drag.startPointer = {x,y};
      render();
      ev.preventDefault();
      return;
    }

    if (phase === Phase.FEET){
      const ff = hitTestFoot(x,y);
      if (!ff) return;
      if (ff.side !== playerSide) return; // only move your own feet

      drag.active = true;
      drag.type = "foot";
      drag.side = ff.side;
      drag.which = ff.footIndex;
      drag.startPointer = {x,y};
      drag.legalTargets = legalMovesForFoot(ff.side, ff.footIndex);
      render();
      ev.preventDefault();
      return;
    }
  }

  function onPointerMove(ev){
    if (!drag.active) return;
    // For this game we donâ€™t need continuous drag ghost; we just redraw spots etc.
    render();
    ev.preventDefault();
  }

  async function onPointerUp(ev){
    if (!drag.active) return;
    const pt = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0] : ev;
    const {x,y} = pointerToCanvasXY(pt.clientX, pt.clientY);

    if (drag.type === "hand"){
      // interpret swipe direction: compare delta to determine cw or ccw
      const dx = x - drag.startPointer.x;
      const dy = y - drag.startPointer.y;
      const dist = Math.hypot(dx,dy);

      // If they clicked without moving, do nothing.
      if (dist < 4) { drag.active=false; render(); return; }

      const hand = hands[drag.which];
      const {cw, ccw} = handNeighbors(hand.pos);

      // Decide cw vs ccw by rough angle relative to center of ring (approx)
      // We'll just use sign of cross product against outward radial vector:
      const center = {x: 28, y: 85}; // approx ring center
      const hp = handPositions[hand.pos];
      const rx = hp.x - center.x;
      const ry = hp.y - center.y;
      const cross = (rx * dy) - (ry * dx);
      const next = (cross < 0) ? cw : ccw; // feels natural

      // Apply move (always allowed to adjacent)
      hand.pos = next;

      // Each time a hand moves, toggle dance layer (your spec)
      danceToggle = (danceToggle + 1) % 2;

      // End hand phase -> feet phase
      phase = Phase.FEET;
      feetToMove = 2;
      lastStepSide = null;
      stepOverlayVisible = false;

      // In Play mode, starting a new turn resets timer for that side
      if (currentMode === Mode.PLAY){
        // spending "energy" each turn start
        if (turnSide === playerSide){
          chest = Math.max(0, chest - 1);
          chestNum.textContent = String(chest);
          if (chest <= 0){
            skintPanel.style.display = "flex";
            stopTurnTimer();
            moveLock = true;
            render();
            drag.active=false;
            return;
          }
        }
        // Reset timer on any hand move because that begins the "hand+feet" segment.
        // (If you'd rather reset at the beginning of each turn, move this to turn switching.)
        turnSecondsLeft = 30;
        startTurnTimer();
      }

      updateTopText();
      drag.active = false;
      render();

      // If player is done and bot's turn begins immediately after feet are done; not now.
      // Also check: if no foot moves possible, you lose after 2 seconds.
      await checkNoMovesLoss(turnSide);

      return;
    }

    if (drag.type === "foot"){
      // pick the closest square among legal targets to where pointer was released
      if (!drag.legalTargets || drag.legalTargets.length === 0){
        drag.active=false; render(); return;
      }
      let best = null;
      let bestD = Infinity;
      for (const sq of drag.legalTargets){
        const p = gridPos[sq];
        const d = Math.hypot(x - (p.x+2), y - (p.y+2));
        if (d < bestD){ bestD = d; best = sq; }
      }
      // require reasonably close to a legal square
      if (best == null || bestD > 20){
        drag.active=false; render(); return;
      }

      // Move the foot
      feet[drag.side][drag.which] = best;

      // Coin pickup (Play): stepping on coin
      if (currentMode === Mode.PLAY && coins.has(best)){
        coins.delete(best);

        // Player steps on coin: open/close flash + recharge chest +1
        if (turnSide === playerSide){
          chest = Math.min(99, chest + 1);
          chestNum.textContent = String(chest);
          chestOpenFlash = 1000; // ms (0.5 open + 0.5 close)
        }
        // Bot steps coin: disappears (already removed)
      }

      // Step overlay: show hoofstep/pawstep when first foot moves
      if (!stepOverlayVisible){
        stepOverlayVisible = true;
        lastStepSide = drag.side;
      } else {
        // second foot moved -> hide step overlay after this
        stepOverlayVisible = false;
        lastStepSide = null;
      }

      feetToMove -= 1;

      drag.active = false;
      drag.legalTargets = [];
      render();

      // if still need to move another foot, stay in feet phase
      if (feetToMove > 0){
        updateTopText();
        // check if remaining foot has any moves; if neither can move, loss
        await checkNoMovesLoss(turnSide);
        return;
      }

      // turn ends -> switch
      endTurnAndSwitch();
      return;
    }
  }

  canvas.addEventListener("mousedown", onPointerDown);
  window.addEventListener("mousemove", onPointerMove);
  window.addEventListener("mouseup", onPointerUp);

  canvas.addEventListener("touchstart", onPointerDown, {passive:false});
  window.addEventListener("touchmove", onPointerMove, {passive:false});
  window.addEventListener("touchend", onPointerUp, {passive:false});

  // =========================
  // No-move loss check (2 seconds)
  // =========================
  async function checkNoMovesLoss(sideToAct){
    if (gameOver) return;

    // Only check once we're in FEET phase for that side
    if (phase !== Phase.FEET) return;
    if (sideHasAnyFootMove(sideToAct)) return;

    // Wait 2 seconds then declare loss (unless state changed)
    moveLock = true;
    updateTopText();
    render();
    await sleep(2000);

    // If still same situation
    if (!gameOver && phase === Phase.FEET && turnSide === sideToAct && !sideHasAnyFootMove(sideToAct)){
      showEnd(opposite(sideToAct));
    } else {
      moveLock = false;
      updateTopText();
      render();
    }
  }

  // =========================
  // Turn switch + bot
  // =========================
  function endTurnAndSwitch(){
    if (gameOver) return;

    // Reset phase
    phase = Phase.HAND;
    feetToMove = 2;
    stepOverlayVisible = false;
    lastStepSide = null;

    // Switch side
    turnSide = opposite(turnSide);

    // Reset play timer per new side
    if (currentMode === Mode.PLAY){
      turnSecondsLeft = 30;
      startTurnTimer();
    }

    updateTopText();
    render();

    // Bot?
    if (turnSide === botSide){
      runBotTurn().catch(console.error);
    }
  }

  async function runBotTurn(){
    if (gameOver) return;
    moveLock = true;
    updateTopText();
    render();

    // In Play: bot takes random total time within 20 seconds for its 3 moves.
    // We approximate by random delays per action that sum to <= 20s.
    let delays = [2000, 2000, 2000]; // default practice delays
    if (currentMode === Mode.PLAY){
      let remaining = 20000;
      delays = [0,0,0].map((_,i) => {
        const maxForThis = remaining - (2-i)*1000;
        const d = clamp(Math.floor(Math.random()*maxForThis), 1000, maxForThis);
        remaining -= d;
        return d;
      });
    }

    // 1) Bot hand move
    await sleep(delays[0]);
    if (gameOver) return;
    botMoveHandStrategic(turnSide);
    danceToggle = (danceToggle + 1) % 2;
    phase = Phase.FEET;
    feetToMove = 2;
    stepOverlayVisible = false;
    lastStepSide = null;

    updateTopText();
    render();

    // If no foot moves, lose after 2s (your rule)
    if (!sideHasAnyFootMove(turnSide)){
      await checkNoMovesLoss(turnSide);
      return;
    }

    // 2) Bot foot move 1
    await sleep(delays[1]);
    if (gameOver) return;
    botMoveOneFoot(turnSide);
    feetToMove = 1;
    stepOverlayVisible = true;
    lastStepSide = turnSide;
    render();

    // still possible?
    if (!sideHasAnyFootMove(turnSide)){
      await checkNoMovesLoss(turnSide);
      return;
    }

    // 3) Bot foot move 2
    await sleep(delays[2]);
    if (gameOver) return;
    botMoveOneFoot(turnSide);
    feetToMove = 0;
    stepOverlayVisible = false;
    lastStepSide = null;
    render();

    // End bot turn
    moveLock = false;
    endTurnAndSwitch();
  }

  function botMoveHandStrategic(side){
    // choose (handIndex, direction cw/ccw) that yields valid foot moves
    // and prefers moving "towards the player" by reducing distance between bot feet and player feet
    const myFeet = feet[side];
    const oppFeet = feet[opposite(side)];

    function distanceScore(feetA, feetB){
      // smaller is better
      let sum = 0;
      for (const a of feetA){
        const ra = rcFromSq(a);
        let best = Infinity;
        for (const b of feetB){
          const rb = rcFromSq(b);
          best = Math.min(best, Math.abs(ra.r-rb.r)+Math.abs(ra.c-rb.c));
        }
        sum += best;
      }
      return sum;
    }

    let best = null;

    for (let hi=0; hi<hands.length; hi++){
      const cur = hands[hi].pos;
      const {cw, ccw} = handNeighbors(cur);
      for (const next of [cw, ccw]){
        // simulate
        const old = hands[hi].pos;
        hands[hi].pos = next;
        const m0 = legalMovesForFoot(side,0).length;
        const m1 = legalMovesForFoot(side,1).length;
        const mobility = m0 + m1;

        const dist = distanceScore(myFeet, oppFeet);

        // score: prefer mobility, then smaller distance
        const score = {mobility, dist};

        if (!best || score.mobility > best.score.mobility ||
           (score.mobility === best.score.mobility && score.dist < best.score.dist)) {
          best = {hi, next, score};
        }
        hands[hi].pos = old;
      }
    }

    if (best){
      hands[best.hi].pos = best.next;
    } else {
      // fallback: move hand 0 cw
      hands[0].pos = handNeighbors(hands[0].pos).cw;
    }
  }

  function botMoveOneFoot(side){
    // Choose a foot + move that (1) is legal (2) prefers stepping toward opponent
    const opp = opposite(side);

    function distToOpp(sq){
      const a = rcFromSq(sq);
      let best = Infinity;
      for (const b of feet[opp]){
        const bb = rcFromSq(b);
        best = Math.min(best, Math.abs(a.r-bb.r)+Math.abs(a.c-bb.c));
      }
      return best;
    }

    let best = null;

    for (let fi=0; fi<2; fi++){
      const moves = legalMovesForFoot(side, fi);
      for (const to of moves){
        const d = distToOpp(to);
        // prefer coin removal in Play (for bot it's just removal; also it denies player recharge)
        const coinBonus = (currentMode === Mode.PLAY && coins.has(to)) ? 0.5 : 0;
        const score = -(d) + coinBonus;
        if (!best || score > best.score){
          best = {fi, to, score};
        }
      }
    }

    if (!best) return;

    feet[side][best.fi] = best.to;

    // coin pickup
    if (currentMode === Mode.PLAY && coins.has(best.to)){
      coins.delete(best.to);
    }
  }

  // =========================
  // Rendering
  // =========================
  function drawImagePixel(img, x, y, opts={}){
    const {flipY=false} = opts;
    if (!img || !img.complete || img.naturalWidth <= 0) return;

    if (!flipY){
      ctx.drawImage(img, x, y);
      return;
    }
    // vertical flip around sprite's box
    ctx.save();
    ctx.translate(x, y + img.naturalHeight);
    ctx.scale(1, -1);
    ctx.drawImage(img, 0, 0);
    ctx.restore();
  }

  function drawSpotAtSquare(sq){
    const p = gridPos[sq];
    const img = assets.spot.img;
    if (img && img.complete && img.naturalWidth > 0){
      ctx.drawImage(img, p.x, p.y);
    } else {
      // fallback spot
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = "#fff";
      ctx.fillRect(p.x, p.y, 8, 8);
      ctx.restore();
    }
  }

  function render(){
    ctx.imageSmoothingEnabled = false;

    // clear
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // background
    if (assets.dog.img.complete) ctx.drawImage(assets.dog.img, 0, 0);

    // tablet
    const tabletY = canvas.height - (assets.tablet.img.naturalHeight || 0);
    if (assets.tablet.img.complete) ctx.drawImage(assets.tablet.img, 0, tabletY);

    // dance base layers (below mice)
    // per your rules: start with dance1; alternate to dance2 on hand moves
    const danceKey = (danceToggle === 0) ? "dance1" : "dance2";
    if (assets[danceKey].img.complete && assets[danceKey].img.naturalWidth > 0){
      ctx.drawImage(assets[danceKey].img, 0, 0);
    }

    // step overlays: show goatstep when hoof moved first hoof, dogstep when paw moved first paw
    if (stepOverlayVisible && lastStepSide){
      const key = (lastStepSide === "hoof") ? "goatstep" : "dogstep";
      if (assets[key].img.complete && assets[key].img.naturalWidth > 0){
        ctx.drawImage(assets[key].img, 0, 0);
      }
    }

    // win overlay if end state
    if (winOverlay){
      const key = winOverlay;
      if (assets[key].img.complete && assets[key].img.naturalWidth > 0){
        ctx.drawImage(assets[key].img, 0, 0);
      }
    }

    // ===== Spots during foot drag
    if (drag.active && drag.type === "foot" && drag.legalTargets){
      for (const sq of drag.legalTargets) drawSpotAtSquare(sq);
    }

    // ===== Coins (Play mode) drawn on top of floor but below feet so you can "step on them"
    if (currentMode === Mode.PLAY && coins.size > 0){
      for (const sq of coins){
        const p = gridPos[sq];
        if (assets.coin.img.complete && assets.coin.img.naturalWidth > 0){
          ctx.drawImage(assets.coin.img, p.x, p.y);
        } else {
          // fallback coin
          ctx.save();
          ctx.fillStyle = "#ff0";
          ctx.fillRect(p.x+2, p.y+2, 6, 6);
          ctx.restore();
        }
      }
    }

    // ===== Hands (stack allowed)
    // Draw both hands; if same pos, second overlays naturally.
    for (const h of hands){
      const p = handPositions[h.pos];
      drawImagePixel(assets.hand.img, p.x, p.y, {flipY:false});
    }

    // ===== Feet
    // If player chose Paw, flip both hoof & paw sprites vertically for correct appearance (as requested).
    // (If you only meant flip the player's pieces, change to: flipY = (invertPlayerSprites && side===playerSide))
    const flipAllFeet = invertPlayerSprites;

    // Draw hoof feet
    for (let i=0;i<2;i++){
      const sq = feet.hoof[i];
      const p = gridPos[sq];
      drawImagePixel(assets.hoof.img, p.x, p.y, {flipY: flipAllFeet});
    }
    // Draw paw feet
    for (let i=0;i<2;i++){
      const sq = feet.paw[i];
      const p = gridPos[sq];
      drawImagePixel(assets.paw.img, p.x, p.y, {flipY: flipAllFeet});
    }

    // ===== Mice clap (always top layer in practice; and also in end/rematch screens)
    const miceKey = (miceFrame === 0) ? "mice1" : "mice2";
    if (assets[miceKey].img.complete && assets[miceKey].img.naturalWidth > 0){
      // Your original stack used shiftedX = stackX - 1.
      // Here we just draw at (0,0) unless your mice assets expect a specific offset.
      // If your repo assets are pre-positioned, keep (0,0).
      ctx.drawImage(assets[miceKey].img, 0, 0);
    }

    // ===== Chest open/close flash (Play) if you add Open.png/Close.png
    if (currentMode === Mode.PLAY && chestOpenFlash > 0){
      // simple timing: first 500ms open then 500ms close
      const phaseMs = chestOpenFlash > 500 ? "open" : "close";
      if (assets[phaseMs].img.complete && assets[phaseMs].img.naturalWidth > 0){
        ctx.drawImage(assets[phaseMs].img, 0, 0);
      }
    }
  }

  // Tick for chest open/close flash
  function tickOverlay(dt){
    if (chestOpenFlash > 0){
      chestOpenFlash = Math.max(0, chestOpenFlash - dt);
    }
  }

  let lastRAF = performance.now();
  function rafLoop(now){
    const dt = now - lastRAF;
    lastRAF = now;
    tickOverlay(dt);
    render();
    requestAnimationFrame(rafLoop);
  }
  requestAnimationFrame(rafLoop);

  // =========================
  // Copy code button
  // =========================
  copyBtn.addEventListener("click", () => {
    const fullCode = document.documentElement.outerHTML;
    const ta = document.createElement("textarea");
    ta.value = fullCode;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    copyBtn.textContent = "Copied!";
    setTimeout(() => (copyBtn.textContent = "Copy Code"), 1500);
    document.body.removeChild(ta);
  });

  // =========================
  // Initial UI
  // =========================
  function setInitialScene(){
    currentMode = Mode.NONE;
    menuRow.style.display = "flex";
    rulesPanel.style.display = "none";
    endPanel.style.display = "none";
    skintPanel.style.display = "none";
    hudRight.style.display = "none";
    startingSide = "hoof";
    selectSide("hoof");
    resetBoard({keepCoins:false});
  }

  setInitialScene();

})();
</script>
</body>
</html>
